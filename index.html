<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#ff7f00">
	<link rel="shortcut icon" href="favicon.ico">
	<title>Benpigchu</title>
</head>
<style>
	html{background:#000;background-image:url("background.svg");background-origin:50%,50%;background-position:50%,50%}
	body,html,#background,#canvas,a{height:100%;width:100%}
	*{margin:0;padding:0}
	#background{position:fixed;overflow:none}
	#canvas{position:absolute}
	#logo{position:absolute;background-image:url("main.png");width:240px;height:240px;background-size:240px;z-index:1;left:0;right:0;top:0;bottom:0;margin:auto;animation-name:logo-intro;animation-duration:1000ms;animation-timing-function:ease}
	a{position:absolute;z-index:3}
	@keyframes logo-intro{
		0%{opacity:0;transform:translateY(-50%)}
		100%{opacity:1;transform:none}
	}
</style>
<body>
	<div id="background">
		<a href="https://benpigchu.com"></a>
		<canvas id="canvas"></canvas>
		<div id="logo"></div>
	</div>
</body>
<script>
	//<![CDATA[
	var nullFilledArray=function(length){
		let array=new Array(length)
		for(var i=0;i<length;i++){
			array[i]=null
		}
		return array
	}
	var makeShader=function(gl,text,typename){
		var type
		if(typename==="vertex"){
			type=gl.VERTEX_SHADER
		}else if(typename==="fragment"){
			type=gl.FRAGMENT_SHADER
		}else{
			return
		}
		var shader=gl.createShader(type)
		gl.shaderSource(shader,text)
		gl.compileShader(shader)
		if(gl.getShaderParameter(shader,gl.COMPILE_STATUS)){
			return shader
		}else{
			console.log(text)
			gl.deleteShader(shader)
			throw new Error("shader init failed")
		}
	}
	var makeProgram=function(gl,vertex,fragment){
		var program=gl.createProgram()
		gl.attachShader(program,vertex)
		gl.attachShader(program,fragment)
		gl.linkProgram(program)
		if(gl.getProgramParameter(program,gl.LINK_STATUS)){
			return program
		}else{
			gl.deleteProgram(program)
			throw new Error("program init failed")
		}
	}
	var setupFbTexture=function(gl,texture,width,height,id){
		gl.activeTexture(gl["TEXTURE"+id])
		gl.bindTexture(gl.TEXTURE_2D,texture)
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST)
		gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,null)
		gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0)
	}
	var positions=new Float32Array([-1,-1,-1,1,1,-1,1,-1,-1,1,1,1])
	var canvas=document.getElementById("canvas")
	var gl=canvas.getContext("webgl",{preserveDrawingBuffer:true})
	var columnCount=80
	var columnWidth=24
	var bufferHeight=1080
	var bufferWidth=columnCount*columnWidth
	var columnData=nullFilledArray(columnCount).map(function(){
		return {offset:Math.random(),start:Math.random(),end:Math.random(),speed:(2+Math.random())/1000,startSpeed:(2+Math.random())/200/Math.PI,endSpeed:(2+Math.random())/200/Math.PI}
	})
	var updateColumnData=function(step){
		columnData=columnData.map(function(data){
			return {offset:(data.offset+data.speed*step)%1,start:(data.start+data.startSpeed)%1,end:(data.end+data.endSpeed)%1,speed:data.speed,startSpeed:data.startSpeed,endSpeed:data.endSpeed}
		})
	}
	var pass1Vertex=""+
	"precision highp float;"+
	"attribute vec2 a_position;"+
	"varying vec2 v_position;"+
	"attribute float a_columnId;"+
	"attribute vec3 a_columnPos;"+
	"varying vec2 v_columnData;"+
	"uniform float u_columnCount;"+
	"void main(){"+
	"    v_position=a_position;"+
	"    v_columnData=mod(sin(radians(360.0*a_columnPos.yz))/10.0-2.0*a_columnPos.xx+vec2(0,0.6),2.0)-1.0;"+
	"    gl_Position=vec4((a_position.x+1.0+2.0*a_columnId)/u_columnCount-1.0,a_position.y,0,1);"+
	"}"
	var pass1Fragment=""+
	"precision highp float;"+
	"varying vec2 v_position;"+
	"varying vec2 v_columnData;"+
	"uniform float u_columnRatio;"+
	"uniform vec2 u_resolution;"+
	"void main(){"+
	"    bool inColumn=abs(v_position.x)<=u_columnRatio;"+
	"    bool inSegment=(v_columnData.t>v_columnData.s)?((v_position.y>v_columnData.s)&&(v_position.y<=v_columnData.t)):(!((v_position.y<=v_columnData.s)&&(v_position.y>v_columnData.t)));"+
	"    gl_FragColor=inSegment&&inColumn?vec4(0.75,0.375,0,1):vec4(0,0,0,1);"+
	"}"
	var pass1program=makeProgram(gl,makeShader(gl,pass1Vertex,"vertex"),makeShader(gl,pass1Fragment,"fragment"))
	gl.useProgram(pass1program)
	var pass1FrameBuffer=gl.createFramebuffer()
	var pass2texture=gl.createTexture()
	gl.bindFramebuffer(gl.FRAMEBUFFER,pass1FrameBuffer)
	setupFbTexture(gl,pass2texture,bufferWidth,bufferHeight,1)
	var pass1PositionAttributeLocation=gl.getAttribLocation(pass1program,"a_position")
	var pass1PositionBuffer=gl.createBuffer()
	var pass1Positions=new Float32Array(columnCount*positions.length)
	for(var i=0;i<columnCount;i++){
		pass1Positions.set(positions,positions.length*i)
	}
	var pass1ColumnIdAttributeLocation=gl.getAttribLocation(pass1program,"a_columnId")
	var pass1ColumnIdBuffer=gl.createBuffer()
	var pass1ColumnIds=new Float32Array(6*columnCount)
	for(var i=0;i<columnCount;i++){
		for(var j=0;j<6;j++){
			pass1ColumnIds[6*i+j]=i
		}
	}
	var pass1ColumnPosAttributeLocation=gl.getAttribLocation(pass1program,"a_columnPos")
	var pass1ColumnPosBuffer=gl.createBuffer()
	var pass1ResolutionUniformLocation=gl.getUniformLocation(pass1program,"u_resolution")
	gl.uniform2f(pass1ResolutionUniformLocation,bufferWidth,bufferHeight)
	var pass1ColumnCountUniformLocation=gl.getUniformLocation(pass1program,"u_columnCount")
	gl.uniform1f(pass1ColumnCountUniformLocation,columnCount)
	var pass1ColumnRatioUniformLocation=gl.getUniformLocation(pass1program,"u_columnRatio")
	gl.uniform1f(pass1ColumnRatioUniformLocation,2/3)
	var pass1Paint=function(){
		gl.bindFramebuffer(gl.FRAMEBUFFER,pass1FrameBuffer)
		gl.viewport(0,0,bufferWidth,bufferHeight)
		gl.useProgram(pass1program)
		gl.enableVertexAttribArray(pass1PositionAttributeLocation)
		gl.bindBuffer(gl.ARRAY_BUFFER,pass1PositionBuffer)
		gl.bufferData(gl.ARRAY_BUFFER,pass1Positions,gl.STATIC_DRAW)
		gl.vertexAttribPointer(pass1PositionAttributeLocation,2,gl.FLOAT,false,0,0)
		gl.enableVertexAttribArray(pass1ColumnIdAttributeLocation)
		gl.bindBuffer(gl.ARRAY_BUFFER,pass1ColumnIdBuffer)
		gl.bufferData(gl.ARRAY_BUFFER,pass1ColumnIds,gl.STATIC_DRAW)
		gl.vertexAttribPointer(pass1ColumnIdAttributeLocation,1,gl.FLOAT,false,0,0)
		var pass1ColumnPoss=new Float32Array(18*columnCount)
		for(var i=0;i<columnCount;i++){
			var offset=columnData[i].offset
			var start=columnData[i].start
			var end=columnData[i].end
			for(var j=0;j<6;j++){
				pass1ColumnPoss[18*i+3*j]=offset
				pass1ColumnPoss[18*i+3*j+1]=start
				pass1ColumnPoss[18*i+3*j+2]=end
			}
		}
		gl.enableVertexAttribArray(pass1ColumnPosAttributeLocation)
		gl.bindBuffer(gl.ARRAY_BUFFER,pass1ColumnPosBuffer)
		gl.bufferData(gl.ARRAY_BUFFER,pass1ColumnPoss,gl.STATIC_DRAW)
		gl.vertexAttribPointer(pass1ColumnPosAttributeLocation,3,gl.FLOAT,false,0,0)
		gl.drawArrays(gl.TRIANGLES,0,6*columnCount)
		updateColumnData(2)
	}
	var pass1UpdateOffset=0
	var pass1UpdateInterval=2
	var pass1UpdateTime=0
	var pass1Updated=false
	var pass1Update=function(){
		pass1Updated=false
		pass1UpdateTime++
		if(pass1UpdateTime>=pass1UpdateInterval){
			pass1Updated=true
			pass1UpdateTime=0
			pass1Paint()
		}
	}
	var pass2Vertex=""+
	"attribute vec2 a_position;"+
	"void main(){"+
	"    gl_Position=vec4(a_position,0,1);"+
	"}"
	var pass2Fragment=""+
	"precision mediump float;"+
	"uniform sampler2D u_image;"+
	"uniform vec2 u_resolution;"+
	"uniform vec2 u_texResolution;"+
	"void main(){"+
	"    vec2 pos=(gl_FragCoord.xy-(u_resolution)/2.0)/u_texResolution+vec2(0.5,0.5);"+
	"    gl_FragColor=texture2D(u_image,vec2(mod(pos.x,1.0),mod(pos.y,1.0)));"+
	"}"
	var pass2program=makeProgram(gl,makeShader(gl,pass2Vertex,"vertex"),makeShader(gl,pass2Fragment,"fragment"))
	gl.useProgram(pass2program)
	var pass2ResolutionUniformLocation=gl.getUniformLocation(pass2program,"u_resolution")
	var pass2TexResolutionUniformLocation=gl.getUniformLocation(pass2program,"u_texResolution")
	gl.uniform2f(pass2TexResolutionUniformLocation,bufferWidth,bufferHeight)
	var pass2ImageUniformLocation=gl.getUniformLocation(pass2program,"u_image")
	gl.uniform1i(pass2ImageUniformLocation,1)
	var pass2PositionAttributeLocation=gl.getAttribLocation(pass2program,"a_position")
	var pass2PositionBuffer=gl.createBuffer()
	var checkCanvasSize=function(){
		if(canvas.width!==window.innerWidth||canvas.height!==window.innerHeight){
			canvas.width=window.innerWidth
			canvas.height=window.innerHeight
			return true
		}
		return false
	}
	var pass2Paint=function(){
		gl.bindFramebuffer(gl.FRAMEBUFFER,null)
		gl.viewport(0,0,gl.canvas.width,gl.canvas.height)
		gl.useProgram(pass2program)
		gl.uniform2f(pass2ResolutionUniformLocation,gl.canvas.width,gl.canvas.height)
		gl.enableVertexAttribArray(pass2PositionAttributeLocation)
		gl.bindBuffer(gl.ARRAY_BUFFER,pass2PositionBuffer)
		gl.bufferData(gl.ARRAY_BUFFER,positions,gl.STATIC_DRAW)
		gl.vertexAttribPointer(pass2PositionAttributeLocation,2,gl.FLOAT,false,0,0)
		gl.drawArrays(gl.TRIANGLES,0,6)
	}
	var pass2Update=function(){
		if(checkCanvasSize()||pass1Updated){
			pass2Paint()
		}
	}
	var init=function(){
		gl.clearColor(0,0,0,1)
		gl.clear(gl.COLOR_BUFFER_BIT)
	}
	var animation=function(){
		pass1Update()
		pass2Update()
		requestAnimationFrame(animation)
	}
	init()
	animation()
	//]]>
</script>
</html>