<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#ff7f00">
	<link rel="shortcut icon" href="favicon.ico">
	<title>Benpigchu</title>
</head>
<style>
	html{background:#000;background-image:url("background.svg");background-position:50%,50%}
	body,html,#background,#canvas,a{height:100%;width:100%}
	*{margin:0;padding:0}
	#background{position:fixed;overflow:none}
	#canvas{position:absolute}
	a{position:absolute;z-index:3}
	#logo{position:absolute;width:240px;height:240px;background-size:240px;z-index:1;left:0;right:0;top:0;bottom:0;margin:auto}
	#logo-outline{position:absolute;background-image:url("outline.png");width:240px;height:240px;background-size:240px;z-index:1;left:0;right:0;top:0;bottom:0;margin:auto;animation-name:logo-outline-intro;animation-duration:1000ms;animation-timing-function:cubic-bezier(0.55, 0.06, 0.68, 0.19)}
	#logo-square{position:absolute;background-image:url("square.png");width:240px;height:240px;background-size:240px;z-index:1;left:0;right:0;top:0;bottom:0;margin:auto;animation-name:logo-square-intro;animation-duration:1000ms;animation-timing-function:cubic-bezier(0.55, 0.06, 0.68, 0.19)}
	#logo-detail{position:absolute;background-image:url("detail.png");width:240px;height:240px;background-size:240px;z-index:1;left:0;right:0;top:0;bottom:0;margin:auto;animation-name:logo-detail-intro;animation-duration:1000ms;animation-timing-function:cubic-bezier(0.22, 0.61, 0.36, 1)}
	@keyframes logo-outline-intro{
		0%{opacity:0}
		40%{opacity:1}
	}
	@keyframes logo-square-intro{
		0%{visibility:hidden}
		40%{visibility:hidden}
		100%{visibility:visible}
	}
	@keyframes logo-detail-intro{
		0%{opacity:0}
		40%{opacity:0}
		100%{opacity:1}
	}
</style>
<body>
	<div id="background">
		<a href="https://benpigchu.com"></a>
		<canvas id="canvas"></canvas>
		<div id="logo">
			<div id="logo-outline"></div>
			<div id="logo-square"></div>
			<div id="logo-detail"></div>
		</div>
	</div>
</body>
<script>
	//<![CDATA[
	const systemVar={}
	systemVar.isMobile=(navigator.userAgent.match(/Android/i)?true:false)||(navigator.userAgent.match(/BlackBerry/i)?true:false)||(navigator.userAgent.match(/iPhone|iPad|iPod/i)?true:false)||(navigator.userAgent.match(/IEMobile/i)?true:false)
	// const
	const cellSize=120
	const cellWidth=16
	const cellHeight=9
	const cellCount=cellWidth*cellHeight
	const patternWidth=cellSize*cellWidth
	const patternHeight=cellSize*cellHeight
	const rectPositions=new Float32Array([-1,-1,-1,1,1,-1,1,-1,-1,1,1,1])
	const canvas=document.getElementById("canvas")
	const gl=canvas.getContext("webgl2")
	const colorBufferFloat=gl.getExtension("EXT_color_buffer_float")
	if(!colorBufferFloat){
		throw new Error("EXT_color_buffer_float webgl2 extension is not available")
	}
	// util
	const getTime=()=>{
		if(performance){
			return performance.now()
		}else{
			return Date.now()
		}
	}
	const checkCanvasSize=()=>{
		if(canvas.width!==window.innerWidth||canvas.height!==window.innerHeight){
			canvas.width=window.innerWidth
			canvas.height=window.innerHeight
			return true
		}
		return false
	}
	const makeShader=(code,type)=>{
		const shader=gl.createShader(type)
		gl.shaderSource(shader,code)
		gl.compileShader(shader)
		if(gl.getShaderParameter(shader,gl.COMPILE_STATUS)){
			return shader
		}else if(gl.isContextLost()){
			// silently fail for context lost
			return null
		}else{
			let error=new Error("shader init failed: "+gl.getShaderInfoLog(shader))
			gl.deleteShader(shader)
			throw error
		}
	}
	const makeProgram=function(vertex,fragment){
		const program=gl.createProgram()
		gl.attachShader(program,vertex)
		gl.attachShader(program,fragment)
		gl.linkProgram(program)
		if(gl.getProgramParameter(program,gl.LINK_STATUS)){
			return program
		}else if(gl.isContextLost()){
			// silently fail for context lost
			return null
		}else{
			let error=new Error("program init failed: "+gl.getProgramInfoLog(program))
			gl.deleteProgram(program)
			throw error
		}
	}
	const setupFbTexture=(fb,tex,id,width,height)=>{
		gl.bindFramebuffer(gl.FRAMEBUFFER,fb)
		gl.activeTexture(gl["TEXTURE"+id])
		gl.bindTexture(gl.TEXTURE_2D,tex)
		// wrap
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.REPEAT)
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.REPEAT)
		// pixel perfect
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST)
		gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA32F,width,height,0,gl.RGBA,gl.FLOAT,null)
		gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,tex,0)
	}
	// pass
	const pass1=(()=>{
		const vertex=[
		"#version 300 es",
		"precision highp float;",
		"uniform vec2 u_dimension;",
		"in vec2 a_position;",
		"in vec2 a_cell;",
		"in float a_shift;",
		"in float a_phase;",
		"out vec2 v_position;",
		"out float v_shift;",
		"out float v_phase;",
		"void main(){",
		"    vec2 interval=vec2(1.0,1.0)/u_dimension;",
		"    vec2 base=interval*a_cell;",
		"    vec2 pos=base*2.0+(a_position+vec2(1.0,1.0))*interval-vec2(1.0,1.0);",
		"    v_position=a_position;",
		"    v_shift=a_shift;",
		"    v_phase=a_phase;",
		"    gl_Position=vec4(pos,0.0,1);",
		"}",
		].join("\n")
		const fragment=[
		"#version 300 es",
		"precision highp float;",
		"in vec2 v_position;",
		"in float v_shift;",
		"in float v_phase;",
		"uniform vec2 u_size;",
		"uniform vec2 u_border;",
		"out vec4 fragColor;",
		"void main(){",
		"    bool box=all(lessThan(abs(v_position),u_size+0.001));",
		"    bool inner=all(lessThan(abs(v_position),u_size-u_border+0.001));",
		"    fragColor=vec4(box?inner?1.0:0.5:0.0,v_phase,v_shift,1.0);",
		"}",
		].join("\n")
		const allRectPositions=(()=>{
			const result=new Float32Array(rectPositions.length*cellCount)
			for(let i=0;i<cellCount;i++){
				result.set(rectPositions,rectPositions.length*i)
			}
			return result
		})()
		const allCells=(()=>{
			const result=new Float32Array(12*cellCount)
			for(let y=0;y<cellHeight;y++){
				for(let x=0;x<cellWidth;x++){
					const i=x+y*cellWidth
					for(let z=0;z<6;z++){
						result[12*i+2*z]=x
						result[12*i+2*z+1]=y
					}
				}
			}
			return result
		})()
		let patternFB
		let program
		let positionAL
		let positionBuf
		let shiftAL
		let shiftBuf
		let phaseAL
		let phaseBuf
		let dimensionUL
		let sizeUL
		let borderUL
		return {
			init:(appPatternFB)=>{
				patternFB=appPatternFB
				program=makeProgram(makeShader(vertex,gl.VERTEX_SHADER),makeShader(fragment,gl.FRAGMENT_SHADER))
				gl.useProgram(program)
				dimensionUL=gl.getUniformLocation(program,"u_dimension")
				gl.uniform2f(dimensionUL,cellWidth,cellHeight)
				sizeUL=gl.getUniformLocation(program,"u_size")
				gl.uniform2f(sizeUL,80/120,80/120)
				borderUL=gl.getUniformLocation(program,"u_border")
				gl.uniform2f(borderUL,8/120,8/120)
				positionAL=gl.getAttribLocation(program,"a_position")
				positionBuf=gl.createBuffer()
				gl.bindBuffer(gl.ARRAY_BUFFER,positionBuf)
				gl.bufferData(gl.ARRAY_BUFFER,allRectPositions,gl.STATIC_DRAW)
				cellAL=gl.getAttribLocation(program,"a_cell")
				cellBuf=gl.createBuffer()
				gl.bindBuffer(gl.ARRAY_BUFFER,cellBuf)
				gl.bufferData(gl.ARRAY_BUFFER,allCells,gl.STATIC_DRAW)
				shiftAL=gl.getAttribLocation(program,"a_shift")
				shiftBuf=gl.createBuffer()
				gl.bindBuffer(gl.ARRAY_BUFFER,shiftBuf)
				phaseAL=gl.getAttribLocation(program,"a_phase")
				phaseBuf=gl.createBuffer()
				gl.bindBuffer(gl.ARRAY_BUFFER,phaseBuf)
			},
			draw:({allShifts,allPhases})=>{
				gl.useProgram(program)
				gl.bindFramebuffer(gl.FRAMEBUFFER,patternFB)
				gl.viewport(0,0,patternWidth,patternHeight)
				gl.enableVertexAttribArray(positionAL)
				gl.bindBuffer(gl.ARRAY_BUFFER,positionBuf)
				gl.vertexAttribPointer(positionAL,2,gl.FLOAT,false,0,0)
				gl.enableVertexAttribArray(cellAL)
				gl.bindBuffer(gl.ARRAY_BUFFER,cellBuf)
				gl.vertexAttribPointer(cellAL,2,gl.FLOAT,false,0,0)
				gl.enableVertexAttribArray(shiftAL)
				gl.bindBuffer(gl.ARRAY_BUFFER,shiftBuf)
				gl.bufferData(gl.ARRAY_BUFFER,allShifts,gl.STATIC_DRAW)
				gl.vertexAttribPointer(shiftAL,1,gl.FLOAT,false,0,0)
				gl.enableVertexAttribArray(phaseAL)
				gl.bindBuffer(gl.ARRAY_BUFFER,phaseBuf)
				gl.bufferData(gl.ARRAY_BUFFER,allPhases,gl.STATIC_DRAW)
				gl.vertexAttribPointer(phaseAL,1,gl.FLOAT,false,0,0)
				gl.drawArrays(gl.TRIANGLES,0,6*cellCount)
			}
		}
	})()
	const pass2=(()=>{
		const vertex=[
		"#version 300 es",
		"precision highp float;",
		"in vec2 a_position;",
		"void main(){",
		"    gl_Position=vec4(a_position,0,1);",
		"}",
		].join("\n")
		const fragment=[
		"#version 300 es",
		"precision highp float;",
		"precision highp sampler2D;",
		"uniform sampler2D u_image;",
		"uniform vec2 u_resolution;",
		"uniform vec2 u_texResolution;",
		"out vec4 fragColor;",
		"void main(){",
		"    vec2 pos=(gl_FragCoord.xy-(u_resolution)/2.0);",
		// For Pixel Perfect on WebGL, add a half pixel offset
		"    vec2 uv=pos/u_texResolution+vec2(0.5,0.5)+vec2(0.5,0.5)/u_texResolution;",
		"    vec4 color1=texture(u_image,mod(uv,1.0));",
		"    vec4 color=texture(u_image,mod(uv+vec2(color1.b,0),1.0));",
		"    float boxBase=color.g<0.5?1.:max(color.g*2.-1.,0.);",
		"    float boxRatio=(1.-boxBase)*(1.-boxBase)*(1.-boxBase);",
		"    float borderBase=abs(color.g*2.-1.);",
		"    float borderRatio=(1.-borderBase)*(1.-borderBase)*(1.-borderBase);",
		"    vec4 box=mix(vec4(0.125,0.125,0.125,1.0),vec4(1.0,0.5,0.0,1.0),boxRatio);",
		"    vec4 border=mix(vec4(0.125,0.125,0.125,1.0),vec4(1.0,0.5,0.0,1.0),borderRatio);",
		"    fragColor=color.r>0.75?box:color.r>0.25?border:vec4(0.0,0.0,0.0,1.0);",
		//"    fragColor=color;",
		"}",
		].join("\n")
		let program
		let resolutionUL
		let texResolutionUL
		let imageUL
		let positionAL
		let positionBuf
		return {
			init:()=>{
				program=makeProgram(makeShader(vertex,gl.VERTEX_SHADER),makeShader(fragment,gl.FRAGMENT_SHADER))
				gl.useProgram(program)
				resolutionUL=gl.getUniformLocation(program,"u_resolution")
				gl.uniform2f(resolutionUL,gl.canvas.width,gl.canvas.height)
				texResolutionUL=gl.getUniformLocation(program,"u_texResolution")
				gl.uniform2f(texResolutionUL,patternWidth,patternHeight)
				imageUL=gl.getUniformLocation(program,"u_image")
				gl.uniform1i(imageUL,0)
				positionAL=gl.getAttribLocation(program,"a_position")
				positionBuf=gl.createBuffer()
				gl.bindBuffer(gl.ARRAY_BUFFER,positionBuf)
				gl.bufferData(gl.ARRAY_BUFFER,rectPositions,gl.STATIC_DRAW)
			},
			draw:(resetSize)=>{
				gl.useProgram(program)
				if(resetSize){
					gl.uniform2f(resolutionUL,gl.canvas.width,gl.canvas.height)
				}
				gl.bindFramebuffer(gl.FRAMEBUFFER,null)
				gl.viewport(0,0,gl.canvas.width,gl.canvas.height)
				gl.enableVertexAttribArray(positionAL)
				gl.bindBuffer(gl.ARRAY_BUFFER,positionBuf)
				gl.vertexAttribPointer(positionAL,2,gl.FLOAT,false,0,0)
				gl.drawArrays(gl.TRIANGLES,0,6)
			}
		}
	})()
	// app
	const bga=(()=>{
		const renderInterval=2
		let lastTime
		let nextDraw
		let patternFB
		let patternTex
		const shift=new Array(cellHeight).fill(null).map(()=>{
			return {
				offset:Math.random(),
				speed:(Math.random()-0.5)*6/100000,
			}
		})
		const phase=new Array(cellCount).fill(null).map(()=>{
			const period=20000+5000*Math.random()
			return {
				offset:Math.random()*period,
				period,
			}
		})
		const allShifts=new Float32Array(6*cellCount)
		const allPhases=new Float32Array(6*cellCount)
		return {
			start:()=>{
				canvas.addEventListener("webglcontextlost",()=>{
					cancelAnimationFrame(nextDraw)
				})
				canvas.addEventListener("webglcontextrestored",()=>{
					bga.init()
				})
				lastTime=getTime()
				bga.init()
			},
			init:()=>{
				gl.clearColor(0,0,0,1)
				patternFB=gl.createFramebuffer()
				patternTex=gl.createTexture()
				setupFbTexture(patternFB,patternTex,0,patternWidth,patternHeight)
				pass1.init(patternFB)
				pass2.init()
				bga.draw(0)
			},
			draw:(frameId)=>{
				const nextFrameId=(frameId+1)%renderInterval
				const resetSize=checkCanvasSize()
				const newTime=getTime()
				if(frameId===0){
					for(let y=0;y<cellHeight;y++){
						shift[y].offset+=shift[y].speed*(newTime-lastTime)+1
						shift[y].offset%=1
						allShifts.fill(shift[y].offset,6*y*cellWidth,6*(y+1)*cellWidth)
						for(let x=0;x<cellWidth;x++){
							const i=x+y*cellWidth
							phase[i].offset+=newTime-lastTime
							phase[i].offset%=phase[i].period
							allPhases.fill(Math.min(phase[i].offset/1000,1),6*i,6*(i+1))
						}
					}
					pass1.draw({allShifts,allPhases})
					pass2.draw(resetSize)
					lastTime=newTime
				}else if(resetSize){
					pass2.draw(resetSize)
				}
				nextDraw=requestAnimationFrame(()=>bga.draw(nextFrameId))
			}
		}
	})()
	// start
	bga.start()
	//]]>
</script>
</html>