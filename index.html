<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#ff7f00">
	<link rel="shortcut icon" href="favicon.ico">
	<title>Benpigchu</title>
</head>
<style>
	html{background:#000;background-image:url("background.svg");background-position:50%,50%;background-repeat:repeat}
	body,html,#background,#canvas,a{height:100%;width:100%}
	*{margin:0;padding:0}
	#background{position:fixed;overflow:none}
	#canvas{position:absolute}
	a{position:absolute;z-index:3}
	#logo{position:absolute;width:240px;height:240px;background-size:240px;z-index:1;left:0;right:0;top:0;bottom:0;margin:auto}
	#logo-square{position:absolute;background-image:url("square.png");width:240px;height:240px;background-size:240px;z-index:1;left:0;right:0;top:0;bottom:0;margin:auto;animation-name:logo-square-intro;animation-duration:1200ms;animation-timing-function:ease-in-out}
	#logo-detail{position:absolute;background-image:url("detail.png");width:240px;height:240px;background-size:240px;z-index:1;left:0;right:0;top:0;bottom:0;margin:auto;animation-name:logo-detail-intro;animation-duration:1200ms;animation-timing-function:ease-in-out}
	@keyframes logo-square-intro{
		0%{opacity:0;transform:scale(0);}
		80%{opacity:1;transform:scale(1);}
		100%{opacity:1}
	}
	@keyframes logo-detail-intro{
		0%{opacity:0}
		80%{opacity:0}
		100%{opacity:1}
	}
</style>
<body>
	<div id="background">
		<a href="https://benpigchu.com"></a>
		<canvas id="canvas"></canvas>
		<div id="logo">
			<div id="logo-square"></div>
			<div id="logo-detail"></div>
		</div>
	</div>
</body>
<script>
	//<![CDATA[
	// const
	const cellSize=120
	const cellWidth=16
	const cellHeight=12
	const cellCount=cellWidth*cellHeight
	const patternWidth=cellSize*cellWidth
	const patternHeight=cellSize*cellHeight
	const canvas=document.getElementById("canvas")
	const context=canvas.getContext("webgpu")
	// util
	const getTime=()=>{
		if(performance){
			return performance.now()
		}else{
			return Date.now()
		}
	}
	const checkCanvasSize=()=>{
		if(canvas.width!==window.innerWidth||canvas.height!==window.innerHeight){
			canvas.width=window.innerWidth
			canvas.height=window.innerHeight
			return true
		}
		return false
	}
	// pass1
	const pass1=(()=>{
		const shader=`
		override cell_width:u32;
		override cell_height:u32;
		@group(0)@binding(0)var<storage,read> referenceOffset:array<vec2f>;
		@group(0)@binding(1)var<storage,read> patternOffset:array<vec2f>;
		@group(0)@binding(2)var<storage,read> patternPhase:array<f32>;

		struct VSOutput{
			@builtin(position)pos:vec4f,
			@location(0)coord:vec2f,
			@location(1)@interpolate(flat)instanceIndex:u32,
			//@location(2)debug:vec4f,
		};

		@vertex fn vs(
			@builtin(vertex_index)vertexIndex:u32,
			@builtin(instance_index)instanceIndex:u32,
		) -> VSOutput{
			let pos=array(
				vec2f(0.,0.),
				vec2f(0.,1.),
				vec2f(1.,0.),
				vec2f(0.,1.),
				vec2f(1.,0.),
				vec2f(1.,1.),
			);
			var output:VSOutput;
			let cell_x=instanceIndex%cell_width;
			let cell_y=instanceIndex/cell_width;
			let coord=pos[vertexIndex];
			let location=(coord+vec2f(f32(cell_x),f32(cell_y)))/vec2f(f32(cell_width),f32(cell_height));
			output.pos=vec4f(location*2.-1.,0.0,1.0);
			output.coord=coord;
			output.instanceIndex=instanceIndex;
			return output;
		}

		@fragment fn fs(
			input:VSOutput
		)->@location(0)vec4f{
			//https://iquilezles.org/articles/voronoilines/
			let cell_x=input.instanceIndex%cell_width;
			let cell_y=input.instanceIndex/cell_width;

			//find cell
			var nearest_x=cell_x;
			var nearest_y=cell_y;
			var nearest_i:i32=0;
			var nearest_j:i32=0;
			var nearest_ref_point=referenceOffset[input.instanceIndex]+0.5;
			var nearest_dist=distance(input.coord,nearest_ref_point);
			for(var i=-2;i<=2;i++){
				for(var j=-2;j<=2;j++){
					let x=(cell_x+u32(i+i32(cell_width)))%cell_width;
					let y=(cell_y+u32(j+i32(cell_height)))%cell_height;
					let ref_point=referenceOffset[x+y*cell_width]+0.5+vec2f(f32(i),f32(j));
					let dist=distance(input.coord,ref_point);
					if(dist<nearest_dist){
						nearest_x=x;
						nearest_y=y;
						nearest_i=i;
						nearest_j=j;
						nearest_ref_point=ref_point;
						nearest_dist=dist;
					}
				}
			}

			var border_dist=16.0;
			//find border_dist
			for(var i=-2;i<=2;i++){
				for(var j=-2;j<=2;j++){
					if(i==0&&j==0){
						continue;
					}
					let x=(nearest_x+u32(i+i32(cell_width)))%cell_width;
					let y=(nearest_y+u32(j+i32(cell_height)))%cell_height;
					let ref_point=referenceOffset[x+y*cell_width]+0.5+vec2f(f32(nearest_i+i),f32(nearest_j+j));
					let dist=abs(dot((ref_point+nearest_ref_point)/2-input.coord,normalize(ref_point-nearest_ref_point)));
					border_dist=min(border_dist,dist);
				}
			}
			let border=border_dist<1./12.;
			let pattern_center=vec2f(f32(nearest_i),f32(nearest_j))+referenceOffset[nearest_x+nearest_y*cell_width]+0.5+patternOffset[nearest_x+nearest_y*cell_width];
			let light=(distance(input.coord,pattern_center)+patternPhase[nearest_x+nearest_y*cell_width]/3.)%(1./3.)<(1./6.);
			let lightness=select(select(4./16.,2./16.,light),0./16.,border);

			return vec4(lightness,lightness,lightness,1.0);
		}
		`.trim()
		let module
		let pipeline
		let referenceOffsetBuffer
		let patternOffsetBuffer
		let patternPhaseBuffer
		let bindGroup
		return {
			init:({device,format})=>{
				module=device.createShaderModule({
					label:"pass1",
					code:shader
				})
				pipeline=device.createRenderPipeline({
					label:"pass1",
					layout:"auto",
					vertex:{
						module,
						entryPoint:"vs",
						constants:{
							cell_width:cellWidth,
							cell_height:cellHeight,
						}
					},
					fragment:{
						module,
						entryPoint:"fs",
						constants:{
							cell_width:cellWidth,
							cell_height:cellHeight,
						},
						targets:[{format}]
					}
				})
				referenceOffsetBuffer=device.createBuffer({
					size:4*2*cellCount,
					usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,
				})
				patternOffsetBuffer=device.createBuffer({
					size:4*2*cellCount,
					usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,
				})
				patternPhaseBuffer=device.createBuffer({
					size:4*cellCount,
					usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,
				})
				bindGroup=device.createBindGroup({
					label:"pass1",
					layout:pipeline.getBindGroupLayout(0),
					entries:[
						{binding:0,resource:{buffer:referenceOffsetBuffer}},
						{binding:1,resource:{buffer:patternOffsetBuffer}},
						{binding:2,resource:{buffer:patternPhaseBuffer}},
					],
				})
			},
			draw:({device,encoder,framebuffer,referenceOffset,patternOffset,patternPhase})=>{
				device.queue.writeBuffer(referenceOffsetBuffer,0,referenceOffset)
				device.queue.writeBuffer(patternOffsetBuffer,0,patternOffset)
				device.queue.writeBuffer(patternPhaseBuffer,0,patternPhase)
				const passDescriptor={
					label:"pass1",
					colorAttachments:[
						{
							clearValue:[0,0,0,1],
							loadOp:'clear',
							storeOp:'store',
							view:framebuffer.createView()
						},
					],
				}
				const pass=encoder.beginRenderPass(passDescriptor);
				pass.setPipeline(pipeline)
				pass.setBindGroup(0,bindGroup)
				pass.draw(6,cellCount)
				pass.end()
			}
		}
	})()
	// pass2
	const pass2=(()=>{
		const shader=`
		@group(0)@binding(0)var<uniform> resolution:vec2f;
		@group(0)@binding(1)var<uniform> tex_resolution:vec2f;
		@group(0)@binding(2)var fb_sampler:sampler;
		@group(0)@binding(3)var fb:texture_2d<f32>;

		@vertex fn vs(
			@builtin(vertex_index)vertexIndex:u32
		) -> @builtin(position)vec4f{
			let pos=array(
				vec2f(-1.,-1.),
				vec2f(-1.,1.),
				vec2f(1.,-1.),
				vec2f(-1.,1.),
				vec2f(1.,-1.),
				vec2f(1.,1.),
			);
			return vec4f(pos[vertexIndex],0.0,1.0);
		}
		@fragment fn fs(
			@builtin(position)pos:vec4f
		)->@location(0)vec4f{
			// add half pixel, convert from pixel index to pixel center position
			// also add a small value to avoid exact half pixel rounding issue
			let coord=pos.xy+0.5+0.001;
			let uv=fract((coord-resolution/2.)/tex_resolution+.5);
			return textureSample(fb,fb_sampler,uv);
		}
		`.trim()
		let module
		let pipeline
		let sampler
		let resolutionBuffer
		let texResolutionBuffer
		let bindGroup
		const resolutionValues=new Float32Array(2)
		const texResolutionValues=new Float32Array([patternWidth,patternHeight])
		return {
			init:({device,format,framebuffer})=>{
				module=device.createShaderModule({
					label:"pass2",
					code:shader
				})
				pipeline=device.createRenderPipeline({
					label:"pass2",
					layout:"auto",
					vertex:{
						module,
						entryPoint:"vs",
					},
					fragment:{
						module,
						entryPoint:"fs",
						targets:[{format}],
					},
				})
				resolutionBuffer=device.createBuffer({
					size:2*4,
					usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,
				})
				resolutionValues[0]=canvas.width
				resolutionValues[1]=canvas.height
				device.queue.writeBuffer(resolutionBuffer,0,resolutionValues)
				texResolutionBuffer=device.createBuffer({
					size:2*4,
					usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,
				})
				device.queue.writeBuffer(texResolutionBuffer,0,texResolutionValues)
				sampler=device.createSampler({
					label:"pass2-fb",
				})
				bindGroup=device.createBindGroup({
					label:"pass2",
					layout:pipeline.getBindGroupLayout(0),
					entries:[
						{binding:0,resource:{buffer:resolutionBuffer}},
						{binding:1,resource:{buffer:texResolutionBuffer}},
						{binding:2,resource:sampler},
						{binding:3,resource:framebuffer.createView()},
					],
				})
			},
			draw:({device,encoder,resetSize})=>{
				if(resetSize){
					resolutionValues[0]=canvas.width
					resolutionValues[1]=canvas.height
					device.queue.writeBuffer(resolutionBuffer,0,resolutionValues)
				}
				const passDescriptor={
					label:"pass2",
					colorAttachments:[
						{
							clearValue:[0,0,0,1],
							loadOp:'clear',
							storeOp:'store',
							view:context.getCurrentTexture().createView()
						},
					],
				}
				const pass=encoder.beginRenderPass(passDescriptor);
				pass.setPipeline(pipeline)
				pass.setBindGroup(0,bindGroup)
				pass.draw(6)
				pass.end()
			}
		}
	})()
	// bga
	const bga=(()=>{
		const renderInterval=1
		let lastTime
		let nextDraw
		let device
		let framebuffer
		const cellData=new Array(cellCount).fill(null).map(()=>{
			const refCycleX=10000+5000*Math.random()
			const refCycleY=10000+5000*Math.random()
			const centerPeriod=15000+5000*Math.random()
			const period=2500+1000*Math.random()
			return {
				refCycleX:refCycleX,
				refCycleY:refCycleY,
				refPhaseX:refCycleX*Math.random(),
				refPhaseY:refCycleY*Math.random(),
				centerXStart:(Math.random()-0.5)*0.5,
				centerYStart:(Math.random()-0.5)*0.5,
				centerXEnd:(Math.random()-0.5)*0.5,
				centerYEnd:(Math.random()-0.5)*0.5,
				centerPeriod:centerPeriod,
				centerProgress:centerPeriod*Math.random(),
				period:period,
				phase:period*Math.random(),
			}
		})
		const referenceOffset=new Float32Array(cellCount*2)
		const patternOffset=new Float32Array(cellCount*2)
		const patternPhase=new Float32Array(cellCount)
		return {
			start:async ()=>{
				lastTime=getTime()
				bga.setupDevice()
				for(let i=0;i<referenceOffset.length;i++){
					referenceOffset[i]=(Math.random()-0.5)*0.7
				}
				for(let i=0;i<patternOffset.length;i++){
					patternOffset[i]=(Math.random()-0.5)*0.5
				}
				for(let i=0;i<patternOffset.length;i++){
					patternPhase[i]=Math.random()
				}
			},
			setupDevice:async ()=>{
				const adapter=await navigator.gpu.requestAdapter()
				device=await adapter.requestDevice()
				bga.init()
				device.lost.then((info)=>{
					cancelAnimationFrame(nextDraw)
					if(info.reason!=="destroyed"){
						bga.setupDevice()
					}
				})
			},
			init:()=>{
				const presentationFormat=navigator.gpu.getPreferredCanvasFormat()
				context.configure({
					device,
					format:presentationFormat,
				})

				framebuffer=device.createTexture({
					label:"fb",
					size:[patternWidth,patternHeight],
					format:presentationFormat,
					usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,
				  });
				pass1.init({device,format:presentationFormat})
				pass2.init({device,format:presentationFormat,framebuffer})

				bga.draw(0)
			},
			draw:(frameId)=>{
				const nextFrameId=(frameId+1)%renderInterval
				const resetSize=checkCanvasSize()
				if(resetSize){
					// TODO: better size handling
					const sizeTooBig=Math.max(canvas.width,canvas.height)>device.limits.maxTextureDimension2D
					canvas.style.visibility=sizeTooBig?"hidden":"visible"
				}
				const newTime=getTime()
				if(frameId===0){
					for(let i=0;i<cellCount;i++){
						const cell=cellData[i]
						cell.refPhaseX+=(newTime-lastTime)
						if(cell.refPhaseX>cell.refCycleX){
							cell.refPhaseX%=cell.refCycleX
						}
						cell.refPhaseY+=(newTime-lastTime)
						if(cell.refPhaseY>cell.refCycleY){
							cell.refPhaseY%=cell.refCycleY
						}
						cell.centerProgress+=(newTime-lastTime)
						if(cell.centerProgress>cell.centerPeriod){
							cell.centerProgress%=cell.centerPeriod
							cell.centerXStart=cell.centerXEnd
							cell.centerYStart=cell.centerYEnd
							cell.centerXEnd=(Math.random()-0.5)*0.5
							cell.centerYEnd=(Math.random()-0.5)*0.5
						}
						cell.phase+=(newTime-lastTime)
						cell.phase%=cell.period
						const centerAnimation=Math.min(1,(cell.centerPeriod-cell.centerProgress)/1000)
						const centerRatio=centerAnimation*centerAnimation*centerAnimation
						referenceOffset[2*i]=Math.sin(Math.PI*2*cell.refPhaseX/cell.refCycleX)/2*0.7
						referenceOffset[2*i+1]=Math.sin(Math.PI*2*cell.refPhaseY/cell.refCycleY)/2*0.7
						patternOffset[2*i]=(centerRatio)*cell.centerXStart+(1-centerRatio)*cell.centerXEnd
						patternOffset[2*i+1]=(centerRatio)*cell.centerYStart+(1-centerRatio)*cell.centerYEnd
						patternPhase[i]=1-cell.phase/cell.period
					}

					lastTime=newTime
				}

				const encoder=device.createCommandEncoder({label:'draw-encoder'});
				if(frameId===0){
					pass1.draw({device,encoder,framebuffer,referenceOffset,patternOffset,patternPhase})
				}
				pass2.draw({device,encoder,resetSize})
				const commandBuffer=encoder.finish()
				device.queue.submit([commandBuffer])

				nextDraw=requestAnimationFrame(()=>bga.draw(nextFrameId))
			}
		}
	})()
	bga.start()
</script>
</html>